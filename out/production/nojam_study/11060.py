import sys

n = int(input())
jump = list(map(int, sys.stdin.readline().split()))  # 입력 받기
dp = [n+1] * n  # n+1 정도면 max limit 가능. n+1로 설정. n으로 해도 되긴 된다.

dp[0] = 0  # 우선 0번째는 0으로. 첫번째 칸은 0번 점프해도 갈 수 있다.

for i in range(n):  # 첫 칸부터 끝 칸까지
    # 점프해서 갈 수 있는 칸들 => 만약 jump[i]가 0이면 (1,1)이라서 안 돈다.
    for j in range(1, jump[i] + 1):
        if i + j < n:  # 점프해서 갈 수 있는 곳이 index 범위 내라면
            # i+j 칸에 몇 번 점프해서 가는지 업데이트 => 기존 값이랑 이전 칸에서 점프해서 오는 것 중에 최소인 것.
            dp[i + j] = min(dp[i] + 1, dp[i + j])
# i 칸에 있다가 j만큼 점프해서 i+j 칸에 온 것. 따라서 i+j는 원래 점프한 수(dp[i+j])나 i에서 점프해서 온 수(dp[i]+1) 중 더 작은 것.
# 내가 고민했던 부분: range(n)이면 0부터 n-1칸을 다 도는 건데, 만약 점프해서 갈 수 없는 곳도 돌면 어떡하지?
# 만약 내가 i번째 칸에서 점프해서 가는걸 구하는데 i가 방문한 적 없는 칸이면 어떡하냐는건데
# 문제가 되지 않음. 왜냐면 우리가 관심있게 업데이트하려는 값은 i번째 칸이 아니라 i+j번쨰 값이기 때문. 우리가 점프해서 갈 수 있는 칸
# i번째 칸에서 점프해서 올 수 있는 칸을 보는 것.
# 그런데 만약 이때 i번째 칸이 간 적이 없는 곳이라면 dp[i]가 n+1로 되어 있을 것.

if dp[n - 1] == n + 1:  # 위에 dp 초기 값을 n으로 설정했다면 이 값도 n+1이 아니라 n이어야 한다.
    print(-1)
else:
    print(dp[n - 1])
